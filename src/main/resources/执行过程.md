

#### 执行过程

  更详细的执行流程分析请看[mybatis-learn]/resources/mybati执行流程分析.md


##### DefaultSqlSession#selectList()
   ```
   @Override
     public <E> List<E> selectList(String statement, Object parameter) {
       return this.selectList(statement, parameter, RowBounds.DEFAULT);
     }
   ```
   
   ```
   // -----------------------------
     // 最后都是从Configuration中获取对应的mappedStatement
     // 然后由执行器调用
     // -----------------------------
     @Override
     public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {
       try {
       // 通过方法名获取对应的mappedStatement
         MappedStatement ms = configuration.getMappedStatement(statement);
         // 委派给执行器执行  
         return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
       } catch (Exception e) {
         throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);
       } finally {
         ErrorContext.instance().reset();
       }
     }
   ```
   
   
   ```
   /**
    * 
    * 对应的sql语句， 执行配置会被封装到本类中
    * 将mapper.xml文件解析包装成MappedStatement
    * 
    * @author Clinton Begin
    */
   public final class MappedStatement {
   
     private String resource;
     private Configuration configuration;
     private String id;
     private Integer fetchSize;
     private Integer timeout;
     // STATEMENT, PREPARED, CALLABLE
     private StatementType statementType;
     private ResultSetType resultSetType;
     // 真实的sql语句， 包括参数
     private SqlSource sqlSource;
     private Cache cache;
     // 参数
     private ParameterMap parameterMap;
     // 结果集 map
     private List<ResultMap> resultMaps;
     private boolean flushCacheRequired;
     private boolean useCache;
     private boolean resultOrdered;
     //UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH;
     private SqlCommandType sqlCommandType;
     private KeyGenerator keyGenerator;
     private String[] keyProperties;
     private String[] keyColumns;
     private boolean hasNestedResultMaps;
     private String databaseId;
     private Log statementLog;
     private LanguageDriver lang;
     private String[] resultSets;
     
     }
   ```
   
##### Executor#query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)    
   
   参数:
      1) mappedStatement: 包含sql语句,执行条件的MappedStatement
      2) parameter: 查询方法参数 
      3) rowBounds: 分页, 查询结果的数量
      4) resultHandler: 用于处理结果集, 一般情况下, 是通过属性注入的, 这里通过参数传递 0.0 
      
   执行器类型:
      1) SimpleExecutor 每次都会预编译sql语句
      2) ReuseExecutor 会复用之前预编译的sql语句
      3) BatchExecutor 批量执行sql语句
      4) CachingExecutor                      

   如何指定执行器类型:
      SqlSessionFactory#openSession(ExecutorType type) 

   
    
    
    
//=========================================

BaseExecutor

```
@SuppressWarnings("unchecked")
  @Override
  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
    if (closed) {
      throw new ExecutorException("Executor was closed.");
    }
    if (queryStack == 0 && ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List<E> list;
    try {
      queryStack++;
      list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;  // 从缓存中获取
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); // 从数据库中查询  
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      // issue #601
      deferredLoads.clear();
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        // issue #482
        clearLocalCache();
      }
    }
    return list;
  }
```


```
private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List<E> list;
    localCache.putObject(key, EXECUTION_PLACEHOLDER); //添加占位符 这是为什么 
    try {
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    localCache.putObject(key, list);  //添加进缓存
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
```


// ==============================================================        
        
 // SimpleExecutor
    ```
      @Override
      public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
        Statement stmt = null;
        try {
          Configuration configuration = ms.getConfiguration();
           // 通过configuration生成对应的StatementHandle执行
          // 在这里添加了对应的插件链
          StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
          stmt = prepareStatement(handler, ms.getStatementLog());
          // 委派给StatementHandler执行, 由resultHandler封装转换结果 
          return handler.query(stmt, resultHandler);
        } finally {
          closeStatement(stmt);
        }
      }
    ```
    
 // SimpleStatementHandler
 
    ```
       @Override
        public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {
          String sql = boundSql.getSql();
      
          // 这里由statement真正执行对应的Sql
          statement.execute(sql);
      
          // 通过参数传递的结果处理器处理返回结果
          return resultSetHandler.handleResultSets(statement);
        }
    ```        
        
  
// ==============================

再看BaseExecutor
```
  @Override
  public void commit(boolean required) throws SQLException {
    if (closed) {
      throw new ExecutorException("Cannot commit, transaction is already closed");
    }
    clearLocalCache();
    flushStatements();  // 如果有延时执行的statement, 在commit前可以调用该方法执行
    if (required) {
      transaction.commit();
    }
  }
  
  @Override
    public List<BatchResult> flushStatements() throws SQLException {
      return flushStatements(false);
    }
  
    public List<BatchResult> flushStatements(boolean isRollBack) throws SQLException {
      if (closed) {
        throw new ExecutorException("Executor was closed.");
      }
      return doFlushStatements(isRollBack);
    }

```  



再看BatchExecutor

```
@Override
  public int doUpdate(MappedStatement ms, Object parameterObject) throws SQLException {
    final Configuration configuration = ms.getConfiguration();
    final StatementHandler handler = configuration.newStatementHandler(this, ms, parameterObject, RowBounds.DEFAULT, null, null);
    final BoundSql boundSql = handler.getBoundSql();
    final String sql = boundSql.getSql();
    final Statement stmt;
    // 委托给statementHandler处理
    if (sql.equals(currentSql) && ms.equals(currentStatement)) {
      int last = statementList.size() - 1;
      stmt = statementList.get(last);
      applyTransactionTimeout(stmt);
      handler.parameterize(stmt);//fix Issues 322
      BatchResult batchResult = batchResultList.get(last);
      batchResult.addParameterObject(parameterObject);
    } else {
      Connection connection = getConnection(ms.getStatementLog());
      stmt = handler.prepare(connection, transaction.getTimeout());
      handler.parameterize(stmt);    //fix Issues 322
      currentSql = sql;
      currentStatement = ms;
      statementList.add(stmt);
      batchResultList.add(new BatchResult(ms, sql, parameterObject));
    }
    // 添加sql语句到statement, 本BatchStatement
    handler.batch(stmt);
    return BATCH_UPDATE_RETURN_VALUE;
  }
```


```
@Override
  public List<BatchResult> doFlushStatements(boolean isRollback) throws SQLException {
    try {
      List<BatchResult> results = new ArrayList<>();
      if (isRollback) {
        return Collections.emptyList();
      }
      for (int i = 0, n = statementList.size(); i < n; i++) {
        Statement stmt = statementList.get(i);
        applyTransactionTimeout(stmt);
        BatchResult batchResult = batchResultList.get(i);
        try {
          // 真正执行批量执行
          batchResult.setUpdateCounts(stmt.executeBatch());
          MappedStatement ms = batchResult.getMappedStatement();
          List<Object> parameterObjects = batchResult.getParameterObjects();
          KeyGenerator keyGenerator = ms.getKeyGenerator();
          if (Jdbc3KeyGenerator.class.equals(keyGenerator.getClass())) {
            Jdbc3KeyGenerator jdbc3KeyGenerator = (Jdbc3KeyGenerator) keyGenerator;
            jdbc3KeyGenerator.processBatch(ms, stmt, parameterObjects);
          } else if (!NoKeyGenerator.class.equals(keyGenerator.getClass())) { //issue #141
            for (Object parameter : parameterObjects) {
              keyGenerator.processAfter(this, ms, stmt, parameter);
            }
          }
          // Close statement to close cursor #1109
          closeStatement(stmt);
        } catch (BatchUpdateException e) {
          StringBuilder message = new StringBuilder();
          message.append(batchResult.getMappedStatement().getId())
              .append(" (batch index #")
              .append(i + 1)
              .append(")")
              .append(" failed.");
          if (i > 0) {
            message.append(" ")
                .append(i)
                .append(" prior sub executor(s) completed successfully, but will be rolled back.");
          }
          throw new BatchExecutorException(message.toString(), e, results, batchResult);
        }
        results.add(batchResult);
      }
      return results;
    } finally {
      for (Statement stmt : statementList) {
        closeStatement(stmt);
      }
      currentSql = null;
      statementList.clear();
      batchResultList.clear();
    }
  }
```


    
    
        