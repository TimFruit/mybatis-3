

#### 执行过程

##### DefaultSqlSession#selectList()
   ```
   @Override
     public <E> List<E> selectList(String statement, Object parameter) {
       return this.selectList(statement, parameter, RowBounds.DEFAULT);
     }
   ```
   
   ```
   // -----------------------------
     // 最后都是从Configuration中获取对应的mappedStatement
     // 然后由执行器调用
     // -----------------------------
     @Override
     public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {
       try {
       // 通过方法名获取对应的mappedStatement
         MappedStatement ms = configuration.getMappedStatement(statement);
         // 委派给执行器执行  
         return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
       } catch (Exception e) {
         throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);
       } finally {
         ErrorContext.instance().reset();
       }
     }
   ```
   
   
   ```
   /**
    * 
    * 对应的sql语句， 执行配置会被封装到本类中
    * 将mapper.xml文件解析包装成MappedStatement
    * 
    * @author Clinton Begin
    */
   public final class MappedStatement {
   
     private String resource;
     private Configuration configuration;
     private String id;
     private Integer fetchSize;
     private Integer timeout;
     // STATEMENT, PREPARED, CALLABLE
     private StatementType statementType;
     private ResultSetType resultSetType;
     // 真实的sql语句， 包括参数
     private SqlSource sqlSource;
     private Cache cache;
     // 参数
     private ParameterMap parameterMap;
     // 结果集 map
     private List<ResultMap> resultMaps;
     private boolean flushCacheRequired;
     private boolean useCache;
     private boolean resultOrdered;
     //UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH;
     private SqlCommandType sqlCommandType;
     private KeyGenerator keyGenerator;
     private String[] keyProperties;
     private String[] keyColumns;
     private boolean hasNestedResultMaps;
     private String databaseId;
     private Log statementLog;
     private LanguageDriver lang;
     private String[] resultSets;
     
     }
   ```
   
##### Executor#query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)    
   
   参数:
      1) mappedStatement: 包含sql语句,执行条件的MappedStatement
      2) parameter: 查询方法参数 
      3) rowBounds: 分页, 查询结果的数量
      4) resultHandler: 用于处理结果集, 一般情况下, 是通过属性注入的, 这里通过参数传递 0.0 
      
   执行器类型:
      1) SimpleExecutor 每次都会预编译sql语句
      2) ReuseExecutor 会复用之前预编译的sql语句
      3) BatchExecutor 批量执行sql语句
      4) CachingExecutor                      

   如何指定执行器类型:
      SqlSessionFactory#openSession(ExecutorType type) 

    // SimpleExecutor
    ```
      @Override
      public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
        Statement stmt = null;
        try {
          Configuration configuration = ms.getConfiguration();
           // 通过configuration生成对应的StatementHandle执行
          // 在这里添加了对应的插件链
          StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
          stmt = prepareStatement(handler, ms.getStatementLog());
          // 委派给StatementHandler执行, 由resultHandler封装转换结果 
          return handler.query(stmt, resultHandler);
        } finally {
          closeStatement(stmt);
        }
      }
    ```
    
    // SimpleStatementHandler
    ```
       @Override
        public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {
          String sql = boundSql.getSql();
      
          // 这里由statement真正执行对应的Sql
          statement.execute(sql);
      
          // 通过参数传递的结果处理器处理返回结果
          return resultSetHandler.handleResultSets(statement);
        }